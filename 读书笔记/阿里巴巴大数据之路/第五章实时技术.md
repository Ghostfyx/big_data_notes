# 第五章 实时技术

### 5.2.3 数据存储

实时任务在运行过程中，会计算很多维度和指标，这些数据需要放在一个存储系统中作为恢复或者关联使用。其中会涉及三种数据类型：

- 中间计算结果——在实时应用处理过程中，会有一些状态的保存(比如去重指标的明细数据)，用于在发生故障时，使用数据库中的数据恢复内存现场
- 最终结果数据——指的是通过ETL处理后的实时结果数据，这些数据是实时更新的，写的频率非常高，可以被下游直接使用
- 维表数据——在离线计算系统中，通过同步工具导入到在线存储系统中，供实时任务来关联实时流数据

数据库分为很多种类型，比如关系型数据库、列式数据库、文档数据库等， 那么在选择实时任务所使用的数据库时应该注意哪些特征呢？

前面提到实时任务是多线程处理的，这就意味着数据存储系统必须能够比较好地支持**多并发读写，并且延时需要在毫秒级**才能满足实时的。

在实践中，一般使用H Base 、Tair 、MongoDB 等列式存储系统。由于这些系统在写数据时是先写内存再落磁盘，因此写延时在毫秒级：读请求也有缓存机制，重要的是多并发读时也可以达到毫秒级延时。

但是这些系统的缺点也是比较明显的，以HBase 为例， 一张表必须要有row key ，而rowkey 是按照ASCII 码来排序的，这就像关系型数据库的索引一样， row key 的规则限制了读取数据的方式。如果业务方需要使用另一种读取数据的方式，就必须重新输出row key 。从这个角度来看， HBase 没有关系型数据库方便。但是H Base 的一张表能够存储几TB 甚至几十TB 的数据，而关系型数据库必须要分库分表才能实现这个量级的数据存储。因此，对于海量数据的实时计算，一般会采用非关系型数据库，以应对大量的多并发读写。

下面介绍在数据统计中表名设计和row key 设计的一些实践经验。

**1. 表名设计**

设计规则：汇总层标识＋数据域＋主维度＋时间维度。例如： dws_trd_s lr_dtr ，表示汇总层交易数据，根据卖家（ sir ）主维度+O 点截至当日(dtr)进行统计汇总。

这样做的好处是，所有主维度相同的数据都放在一张物理表中，避免表数量过多，难以维护。另外，可以从表名上直观地看到存储的是什么数据内容，方便排查问题。

**2. rowkey设计**

设计规则： MD5 ＋主维度＋维度标识＋子维度1 ＋时间维度＋子维度2

例如：卖家ID 的MD5 前四位＋卖家ID+ app ＋ 一级类目ID+ ddd ＋二级类目ID 。

以M D5 的前四位作为row key 的第一部分，可以把数据散列，让服务器整体负载是均衡的，避免热点问题。在上面的例子中，卖家ID 属于主维度，在查数据时是必传的。每个统计维度都会生成一个维度标识，以便在rowkey 上做区分。

### 5.2.4 数据服务

实时数据落地到存储系统中后，使用方就可以通过统一的数据服务获取到实时数据。比如下一章将要讲到的OneService ，其好处是：

- 不需要直连数据库，数据源等信息在数据服务层维护，这样当存储系统迁移时，对下游是透明的
- 调用方只需要使用服务层暴露的接口，不需要关心底层取数逻辑的实现
- 屏蔽存储系统间的差异，统一的调用输出，便于分析和监控下游使用情况。

## 5.3 流式数据模型

