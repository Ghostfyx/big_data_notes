# chap09 Search Engiene 

本章介绍使用MapReduce/Spark算法实现搜索引擎。一般的搜索引擎会在以下方面改善用户体验：

- 帮助用户查找信息
- 减少搜索与导航时间
- 提高用户满意度，而且可以激励用户经常光顾网站

搜索引擎可以预测或者推荐：

- 用户还没有评级，购买或者访问商品
- 用户还没有浏览过商品

## 1. 购买过该商品的顾客还购买了哪些商品

大多数电商网站，都会在网站上使用“购买过该商品的顾客还购买了哪些商品”特性来推荐商品。下面使用MapRedue/Spark实现简单的商品推荐系统。

## 1.1输入

假设输入一个大型交易集（交易日志包含大量数据：交易ID，日期，价格等），我们使用

```
<userId><,><bought-item>
```

### 1.2 期望输出

推荐引擎输出键值对，Key是一个商品，Value是一个列表，包含购买过这个商品的顾客最长购买的其他商品。

## 1.3 MapReduce解决方案

使用两次迭代完成：

- 阶段1：生成同一个用户购买的商品列表，分组MapReduce计算框架处理
- 阶段2：解决商品列表共现问题，我们使用**Stripes（条纹）设计模式**解决。

### 1.3.1 Stripes设计模式

Stripes（条纹）作为一个设计模式，它的主要思想是将键值对分组为一个关联数组。下面给出了传统Mapper输出和Stripes模式输出的区别。

​                  												Mapper输出：传统方法

| 键         | 值   |
| ---------- | ---- |
| $(k, k_1)$ | 1    |
| $(k, k_2)$ | 2    |
| $(k, k_3)$ | 3    |
| $(z, z_1)$ | 4    |
| $(z, z_2)$ | 5    |

Stripes方法基本思想不是输出很多键值对，只针对每个条纹发出一个键值对，如下所示：

| 键   | 值                             |
| ---- | ------------------------------ |
| k    | $\{(k_1,1),(k_2,2),(k_3, 3)\}$ |
| z    | $\{(z_1,4),(z_2,5)\}$          |

Stripes方法为每个自然键创建一个关联数组或散列表，并归约各个映射器发出的键值对数据，将各个映射器发出的数据转换为一个复杂对象，可以减少键值对排序和Shuffle洗牌。

Stripes优点：

- 与传统方法相比，由于生成的键值对数量更少，需要排序与Shuffle的也更少；
- 可以充分利用组合器；
- 提供更好的性能；

Stripes缺点：

- 较难实现，因为每个Mapper发出的值是一个关联数组，必须为这个关联数组写一个串行化器和反串行化器；
- 底层对象是重量级对象
- Stripes方法将数据保存在Mapper内存中，要去映射器有足够多的RAM保存。

### 1.3.2 MapReduce实现

见项目代码，主要有Mapper，combiner和Reducer实现经常一起购买的商品挖掘，与上一章频繁项集挖掘有直接关系。

## 1.4 经常一起购买商品的FBT特性

购买关联（**FBT:** Frequently bought together组合购买, Customers who bought this item also bought others）是一种用户行为定向技术，充分利用用户购买历史来选择和现实这个用户可能希望购买的其他相关商品。例如：搜索商品A，会出现其他经常与它一起购买的商品。

一般电商网站会收集用户购买习惯的有关数据，通过使用关联规则学习，可以确定哪些商品会经常一起购买，并利用这些信息进行营销。

### 1.4.1 输入

假设交易为T，商品为P，交易数据如下：

| 交易  | 购买商品                         |
| ----- | -------------------------------- |
| $T_1$ | $\{P_{1,1},P_{1,2},...P_{1,k}\}$ |
| $T_2$ | $\{P_{2,1},P_{2,2},...P_{2,k}\}$ |

### 1.4.2 期望输出

目标是建立一个散列表，Key为商品，Value是经常一起购买的其他商品列表。

| 商品  | 高频购买商品  |
| ----- | ------------- |
| $P_1$ | $\{P_2,P_3\}$ |
| $P_2$ | $\{P_3\}$     |
| $P_3$ | $\{P_1\}$     |

### 1.4.3 MapReduce/Spark实现

类似于频繁项集挖掘的实现思路，具体实现见代码

## 1.5 推荐连接

本节使用Hadoop/Spark实现有关联的人推荐。Spark提供了GraphX API来完成图和图并行计算，本节暂时只使用Spark API。

所有用户之间的好友关系可以表示为一个图，