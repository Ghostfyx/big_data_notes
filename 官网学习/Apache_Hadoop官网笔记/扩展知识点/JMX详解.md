# Linux挂载详解

## 1. linux文件结构

文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。目录提供了管理文件的一个方便而有效的途径。　　

linux使用标准的目录结构，在安装的时候，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。

linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。微软的DOS和windows也是采用树型结构，但是在DOS和windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。

例如：

有一块硬盘，分成了4个分区，分别是/,/boot,/usr, windows下的fat。对于/和/boot或者/和/usr，它们是从属关系；对于/boot和/usr，它们是并列关系。 

如果把windows下的fat分区挂载到/mnt/winc下，那么对于/mnt/winc和 /usr或/mnt/winc和/boot来说，它们是从属于目录树上没有任何关系的两个分支。

因为linux是一个多用户系统，制定一个固定的目录规划有助于对系统文件和不同的用户文件进行统一管理。但就是这一点让很多从windows转到linux的初学者感到头疼。下面列出了linux下一些主要目录的功用。

```
/         （这就是著名的根）
├── bin         (你在终端运行的大多数程序，比如cp、mv...)
├── boot         (内核放在这里，这个目录也经常被作为某个独立分区的挂载点)
│   └── grub   (grub引导程序和引导菜单就放在这里)
├── cdrom
├── dev         (存放设备文件，这里相当于一个设备管理器，由系统自动生成。视硬件环境不同变化很大)
│   ├── block
│   ├── bsg
│   ├── bus
│   ├── char
│   ├── disk         (磁盘信息，要挂载硬盘分区就要注意这里的信息喽)
│   │   ├── by-id      (硬盘分区的永久性符号链接)
│   │   ├── by-label   (按卷标识别的硬盘分区，常用于挂载)
│   │   ├── by-path   (硬盘分区的节点链接)
│   │   └── by-uuid   (按UUID识别的硬盘分区，常用于挂载)
│   ├── dri
│   ├── fd
│   ├── input
│   ├── net
│   ├── pts
│   ├── shm
│   └── snd
├── etc         (存放所有程序和系统的配制文件和全局变量，对所有用户生效，非常值得备份)
├── home         (这就是著名的home目录了，注意不是”家目录”，强烈建议把一个独立分区挂载到这里！)
│   ├── adagio(这才是我真正的家！一般来说目录名就是帐号名，当然也可以不是。命令行中用波浪线～代表这里)
│   ├── MNT      (这是我挂载其它硬盘分区的地方，你可以看到用硬盘品牌、容量或用途区分的目录名)
│   │   ├── MAX40NT1   (迈拓40G)
│   │   ├── ST160NT1   (希捷160G第一分区,下面两个类似)
│   │   ├── ST160NT2
│   │   ├── ST160SYS
│   │   ├── ST320G      (希捷320G)
│   │   │   ├── MOVIE
│   │   │   ├── MUSIC
│   │   │   └── P2P   (电驴、BT的缓冲区)
│   │   ├── ST80G      (希捷80G)
│   │   │   ├── PROGRAM
│   │   │   ├── ST80PE
│   │   │   └── YEAR
│   │   └── WD1000      (西数1T)
│   │       ├── WD2
│   │       ├── WD3
│   │       ├── WD5
│   │       ├── WD6.Lib
│   │       └── WD7
│   └── test   (我建立的另一个帐号的家目录，专门用于测试，一旦搞到无法收拾的地步，只需简单的
│                把里面的所有文件删除，就可以恢复默认。实际上你可以拥有无数个帐号)
├── lib         (所有程序共享的库文件)
├── lost+found   (磁盘扫描出现的丢失的数据)
├── media      (你在文件管理器里点击后自动挂载的分区就在这里，按卷标命名，没有卷标则按大小命名)
├── mnt         (同样用于挂载磁盘，这是最传统的位置，喜欢挂哪里随便)
├── opt         (某些特殊的程序喜欢把数据放在这里，比如JAVA)
├── proc     (当前系统所有的详细信息，这里的”文件”并不存在于硬盘中，而是在内存或缓存里，每次启动后都不一样)
├── root       (这是系统最高权威root用户的家！他是老大，所以不住在/home里，那里是草民住的)
├── sbin  (类似/bin，存放常用程序，但这里的程序都是要命的，比如格式化，所以只有root用户或sudo程序有权使用)
├── srv         (一些服务所要访问的文件)
├── sys         (系统的核心文件，类似/proc，不必管它)
├── tmp    (存放临时文件，所有用户均可使用，不过你要小心啊，这里的所有文件一旦重启就全没了，自动清空的)
├── usr    (在X下使用的所有程序数据都在这里了，包括图标、manual等。所有用户都可以使用。也是最庞大的目录)
└── var         (variation，顾名思义就是变量，这里存放系统中经常变化的数据。和/tmp不同啊，很有用的地方)
    ├── backups
    ├── cache
    │   └── apt
    │        └── archives (存放安装的所有程序的deb包！重装系统时太有用了，一定要备份好，到时候放回来。
    │                     建议把整个/var单独挂载到一个独立分区，像/home一样。这样你重装好系统后，只
    │                      需要简单的把整个分区挂载到/var就行了，省去了备份-还原的时间。要知道这些deb包
    │                      可不是几十M而已，而是有可能几百M、几个G，一来一回可够呛的。也可以单独挂载
    │                      一个分区到/var/cache/apt/archives，其他的都不要。
    │                      当然，这样又增加了一点系统构造的复杂度，喜欢怎样请自己斟酌。)
    ├── crash
    ├── games
    ├── lib
    ├── local
    ├── lock
    ├── log      (呵呵，这里的文件是系统运行的完整记录，出了问题一定要来这里看看)
    ├── mail      (这里是存放所有用户email的地方)
    ├── opt
    ├── run
    ├── spool
    └── tmp
```

## 2. Linux文件系统

文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。

linux文件系统使用索引节点来记录文件信息，作用像windows的文件分配表。索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号。

linux文件系统将文件索引节点号和文件名同时保存在目录中。所以，目录只是将文件的名称和它的索引节点号结合在一起的一张表，目录中每一对文件名称和索引节点号称为一个连接。 　　

对于一个文件来说有唯一的索引节点号与之对应，对于一个索引节点号，却可以有多个文件名与之对应。因此，在磁盘上的同一个文件可以通过不同的路径去访问它。可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。

连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是： 　　

**硬连接**

1. 原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；　　
2. 硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；　　
3. 由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。 

**符号连接**

用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。可以删除原有的文件而保存连接文件，没有防止误删除功能。

## 3. 挂载文件系统

由上一节知道，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。**这里所说的“按一定方式”就是指的挂载**。

将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点。

注意：

- 挂载点必须是一个目录
- 一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。对于其他操作系统建立的文件系统的挂载也是这样。但是需要理解的是：光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的。光盘是ISO9660；软盘是fat16或ext2；windows NT是fat16、NTFS；windows98是fat16、fat32；windows2000和windowsXP是fat16、fat32、NTFS。

挂载时使用mount命令：

```
格式：mount [-参数] [设备名称] [挂载点] 　　

其中常用的参数有 　　　　
-t<文件系统类型> 指定设备的文件系统类型，常见的有：　　　　
minix linux最早使用的文件系统　　　　
ext2 linux目前常用的文件系统　　　　
msdos MS-DOS的fat，就是fat16 　　　　
vfat windows98常用的fat32 　　　　
nfs 网络文件系统　　　　
iso9660 CD-ROM光盘标准文件系统　　　　
ntfs windows NT 2000的文件系统　　　　
hpfs OS/2文件系统　　　　
auto 自动检测文件系统　　　　
-o<选项> 指定挂载文件系统时的选项。有些也可用在/etc/fstab中。常用的有　
codepage=XXX 代码页　　　　
iocharset=XXX 字符集　　　　
ro 以只读方式挂载　　　　
rw 以读写方式挂载　　　　
nouser 使一般用户无法挂载　　　　
user 可以让一般用户挂载设备 　
```

提醒一下，mount命令没有建立挂载点的功能，因此你应该确保执行mount命令时，挂载点已经存在。（不懂？说白了点就是你要把文件系统挂载到哪，首先要先建上个目录）。

例子：windows98装在hda1分区，同时计算机上还有软盘和光盘需要挂载。

```
# mk /mnt/winc 　　　　
# mk /mnt/floppy 　　　　
# mk /mnt/cdrom 　　　　
# mount -t vfat /dev/hda1 /mnt/winc 　　　　
# mount -t msdos /dev/fd0 /mnt/floppy 　　　　
# mount -t iso9660 /dev/cdrom /mnt/cdrom 　
```

现在就可以进入/mnt/winc等目录读写这些文件系统了。

如果你的windows98目录里有中文文件名，使用上面的命令挂载后，显示的是一堆乱码。这就要用到 -o 参数里的codepage iocharset选项。codepage指定文件系统的代码页，简体中文中文代码是936；iocharset指定字符集，简体中文一般用cp936或gb2312。 　　

当挂载的文件系统linux不支持时，mount一定报错，如windows2000的ntfs文件系统。可以重新编译linux内核以获得对该文件系统的支持。关于重新编译linux内核，就不在这里说了。

## 4. 自动挂载

每次开机访问windows分区都要运行mount命令显然太烦琐，为什么访问其他的linux分区不用使用mount命令呢？　　
其实，每次开机时，linux自动将需要挂载的linux分区挂载上了。那么我们是不是可以设定让linux在启动的时候也挂载我们希望挂载的分区，如windows分区，以实现文件系统的自动挂载呢？这是完全可以的。在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。

我的/etc/fstab文件如下：