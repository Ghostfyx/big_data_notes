# Event Time

## 1. Event Time / Processing Time / Ingestion Time

Flink在流处理项目中支持不同的时间语义：

- **Processing time**：processing time指的是在执行各自的操作的计算机的系统时间

	当流式程序按处理时间运行时，所有基于时间的操作(如时间窗口)都将使用运行相应操作的计算机的系统时钟， 每小时处理时间窗口将包括系统时钟指示整小时的时间之间到达特定操作员的所有记录。 例如，如果应用程序在9:15 am开始运行，则第一个每小时处理时间窗口将包括在9:15 am和10:00 am之间处理的事件，下一个窗口将包括在10:00 am和11:00 am之间处理的事件，依此类推。

	处理时间是最简单的时间概念，不需要流和机器之间的协调。 它提供了最佳的性能和最低的延迟。 但是，在分布式和异步环境中，处理时间不能提供确定性，因为它容易受到记录到达系统(例如从消息队列)到达系统的速度，记录在系统内部操作算子之间流动的速度以及中断的影响。

- **Event time:**事件时间是每个事件在其生产设备上发生的时间。 该时间通常在它们进入Flink之前嵌入到记录中，并且可以从每个记录中提取事件时间戳。 在事件时间中，时间的进度取决于数据，而不取决于任何挂钟。 事件时间程序必须指定如何生成事件时间水印，这是信号事件时间进展的机制。 该水印机制将在下面的后面部分中介绍

	在理想情况下，事件时间处理将产生完全一致且确定的结果，而不管事件何时到达或它们的顺序如何。 但是，除非已知事件是按时间戳（按时间戳）到达的，否则事件时间处理会在等待无序事件时产生一定的延迟。 由于只能等待有限的时间，因此这限制了确定性事件时间应用程序的可用性。

	假设所有数据都已到达，事件时间操作将按预期方式运行，即使在处理无序或迟到的事件或重新处理历史数据时，也会产生正确且一致的结果。 例如，每小时事件时间窗口将包含所有带有落入该小时事件时间戳的记录，无论它们到达的顺序或处理的时间。

- **Ingestion time**：事件进入Flink的时间，在source操作处，每条记录将source的当前时间作为时间戳记，并且基于时间的操作（例如时间窗口）引用该时间标记。

	读取时间从概念上介于事件时间和处理时间之间。 与处理时间相比，它稍微贵一点，但结果却更可预测。由于摄取时间使用稳定的时间戳（在源处分配了一次），因此对记录的不同窗口操作将引用相同的时间戳，而在处理时间中，每个窗口操作都可以将记录分给不同的窗口(基于本地系统时钟和 任何运输延误)。

	与事件时间相比，接收时间程序无法处理任何乱序事件或延迟数据，但程序无需指定如何生成水印。

	在内部，将接收时间视为事件时间，但具有自动时间戳分配和自动水印生成功能。

	![](https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/times_clocks.svg)

## 2. Setting a Time Characteristic

Flink DataStream程序的第一部分通常是设置基本时间特性，该设置定义数据流源的行为方式(例如，它们是否将分配时间戳)，以及诸如`KeyedStream.timeWindow(Time.seconds(30))`之类的窗口操作应使用什么时间概念。

下面示例展示了Flink应用在小时窗口的聚集，窗户的行为与时间特征相适应

```java
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        // 设置时间基本属性特征为事件时间
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStream stream = env.addSource(new FlinkKafkaConsumer010<Object>(topic, schema, props));
        stream.keyBy((event) ->event.getUser())
                .timeWindow(Time.hours(1))
                .reduce((a, b)->{a.add(b)}).addSink(...)
```

请注意，为了在事件时间中运行此示例，程序需要使用直接为数据定义事件时间并发出水印，或者程序必须在source之后注入Timestamp Assigner＆Watermark Generator。 这些功能描述了如何访问事件时间戳，以及事件流呈现出何种程度的乱序。

## 3. Event Time and Watermarks

Flink从DataFlow模型中实现了很多技术，有关事件时间和水印的介绍可以查看下面文章：

- [Streaming 101](https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101) by Tyler Akidau
- The [Dataflow Model paper](https://research.google.com/pubs/archive/43864.pdf)

支持事件时间的流处理器需要一种测量事件时间进度的方法。 例如，当事件时间超过一个小时结束时，需要通知构建每小时窗口的窗口操作，以便该操作可以关闭正在进行的窗口。

事件时间可以独立于处理时间进行。 例如，在一个程序中，操作的当前事件时间可能会稍微落后于处理时间(考虑到事件接收的延迟)，而两者均以相同速度进行。 另一方面，另一个流处理程序可以通过快速转发已经在Kafka主题(或另一个消息队列)中缓存的一些历史数据来在数周的事件时间内进行处理，而处理时间仅为几秒钟。

Flink中用于衡量事件时间进度的机制是Watermark。水印作为数据流的一部分流动，并带有时间戳t。 `Watermark(t)`声明事件时间已在该流中达到时间t，这意味着该流中不应再有时间戳$t'<= t$的元素(即，时间戳早于或等于水印的事件)。

下图显示了带有(逻辑)时间戳记的事件流，以及串联的水印。 在此示例中，事件是按顺序排列的(相对于其时间戳)，这意味着水印只是流中的周期性标记。

![](https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/stream_watermark_in_order.svg)

水印对于乱序流至关重要，如下图所示，其中事件不是按其时间戳排序的。 通常，水印是一个声明，即到流中的那个点，直到某个时间戳的所有事件都应该到达。 一旦水印到达操作，操作就可以将其内部事件时钟提前到水印的值。

请注意，事件时间是由新创建的一个（或多个）流元素从产生它们的事件或触发了创建这些元素的水印中继承的。

## 4. Watermarks in Parallel Streams

水印在源函数处或源函数之后直接生成。 源函数的每个并行子任务通常独立生成其水印。 这些水印定义了该特定并行源处的事件时间。

随着水印在流式传输程序中的流动，它们比事件时间提前到达操作处。每当操作提前其事件时间时，都会为其后续操作员在下游生成新的水印。

一些操作消耗多个输入流; 例如，一个 union，或者跟随 keyBy（…）或 partition（…）函数的运算符。 这样的操作当前事件时间是其输入流的事件时间的最小值。 由于其输入流更新其事件时间，因此操作也是如此。

![](https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/parallel_streams_watermarks.svg)

## 5. Late Elements

某些元素可能会违反水印条件，这意味着即使在发生watermark(t)之后，也会出现更多时间戳为$t'<= t$的元素。 实际上，在许多现实世界的设置中，某些元素可以任意延迟，从而无法指定某个事件时间戳记的所有元素都将发生的时间。 此外，即使可以限制延迟，通常也不希望将水印延迟太多，因为这会导致事件时间窗的评估延迟过多。

由于这个原因，流式传输程序可能会明确期望某些延迟元素。 延迟元素是指系统的事件时间时钟(由水印指定)在经过延迟时间戳之后的时间到达的元素。 有关如何在事件时间窗口中使用延迟元素的更多信息，请参见允许延迟。

